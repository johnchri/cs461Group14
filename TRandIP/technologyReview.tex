%Copyright 2014 Jean-Philippe Eisenbarth
%This program is free software: you can
%redistribute it and/or modify it under the terms of the GNU General Public
%License as published by the Free Software Foundation, either version 3 of the
%License, or (at your option) any later version.
%This program is distributed in the hope that it will be useful,but WITHOUT ANY
%WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
%PARTICULAR PURPOSE. See the GNU General Public License for more details.
%You should have received a copy of the GNU General Public License along with
%this program.  If not, see <http://www.gnu.org/licenses/>.

%Based on the code of Yiannis Lazarides
%http://tex.stackexchange.com/questions/42602/software-requirements-specification-with-latex
%http://tex.stackexchange.com/users/963/yiannis-lazarides
%Also based on the template of Karl E. Wiegers
%http://www.se.rit.edu/~emad/teaching/slides/srs_template_sep14.pdf
%http://karlwiegers.com
% \documentclass[letterpaper,10pt]{article}
\documentclass{scrreprt}
\usepackage{listings}
\usepackage{underscore}
\usepackage[bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{alltt}
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{enumitem}

\usepackage{geometry}

\usepackage{titling}
\usepackage{rotating}
\usepackage{pgfgantt}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{anyfontsize}

\ganttset{group/.append style={orange},
milestone/.append style={red},
progress label node anchor/.append style={text=red}}

\geometry{textheight=8.5in, textwidth=6in}
\hypersetup{
    bookmarks=false,    % show bookmarks bar?
    pdftitle={Software Requirement Specification},    % title
    pdfauthor={Jean-Philippe Eisenbarth},                     % author
    pdfsubject={TeX and LaTeX},                        % subject of the document
    pdfkeywords={TeX, LaTeX, graphics, images}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,       % color of internal links
    citecolor=black,       % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=purple,        % color of external links
    linktoc=page            % only page is linked
}%
\def\myversion{1.0 }
\date{}
%\title{%

%}
\usepackage{hyperref}
\begin{document}

\begin{flushright}
    \rule{16cm}{5pt}\vskip1cm
    \begin{bfseries}
        \Huge{Technology Review and Implementation Plan}\\
        \vspace{1.9cm}
        for\\
        \vspace{1.9cm}
        Deep Learning on Embedded Platform\\
        \vspace{1.9cm}
        \LARGE{Version \myversion}\\
        \vspace{1.9cm}
        Prepared by Christopher Johnson, Luay Alshawi, Gabe Morey\\
        \vspace{1.9cm}
        CS 461 Fall Term\\
        \vspace{1.9cm}
        \today\\
    \end{bfseries}
\end{flushright}


\chapter{Abstract}
Abstract ....

\chapter{Technologies}
\section{Visual Library}
\subsection{Open CV}
An OpenCV (Open Source Computer Vision) is a library that can be used with tons of different languages(C, C++, Java, Python, etc.).
 It provides standard things such as image capture, Faces recognition, Gesture recognition, Motion tracking, Mobile robotics, Object identification and Image manipulation.
 OpenCV was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in the commercial products.
 Being a BSD-licensed product, OpenCV makes it easy for businesses to utilize and modify the code (Team).
\subsection{SimpleCV}
SimpleCV is a framework including several libraries and uses Python for scripting.
Due to the nature of python, it can either run scripts or use an interactive shell to do computer vision computation and related tasks.
With it, you get access to several high-powered computer vision libraries such as OpenCV – without having to first learn about bit depths, file formats, color spaces, buffer management, eigenvalues, or matrix versus bitmap storage (Sight Machine, Inc).
\subsection{Community Core Vision}
CCV (Community Core Vision) library is an open source/cross-platform solution for blob tracking with computer vision.
Supports a wide range of camera devices with the ability to stitch and switch in between sensors on the fly.
It is built on C++ for real-time performance and stability using common frameworks including OpenCV and open Frameworks.
To minimize the code base, it gives up non-essential functionalities aggressively.
It is not a library for you to experiment different algorithms.
It is a library for you to use in your applications (LiuLiu, 2012).




\section{Jetson...}

The role of making sure everything runs smoothly on the platform required of us to implement out solution on can be devided into three categories.
These categories are finding the right communication methods with our client for group meetings, deciding what camera technology we need, and figuring out the best way to visialize the data.
For each of these three tasks I have found three approaches that I have research and given thorough consideration.
This is to ensure that we are making the best possible decisions when working with the Jetson TX1.

One of the most omportant aspects of a group project is communication.
This is especially true when we're working with a client who has tasked us with using a certain platform.
There will most likely be many times when we'll need to discuss something about the Jetson.
There are many very popular and suitable tools available to conduct online meetings.
These include Skype, Discord, and Team Speak.
Skype was founded in 2003 by Niklas Zennström.
Skype has a lot of features that Discord and Team Speak don't have.
One of these features includes screen sharing.
This feature could be very beneficial during group meetings when a group member has to explain something visually.
Our group has used Skype twice in the past and the sound quality was good enough for everyone to understand each other.
Discord and Team Speak also do not allow video calls, they only provide groups to voice and text chat.
One down side with Skype however is the presence of bugs.
Among reviewers, skype is the least reliable.
A huge factor in our decision on with communication tool to use is what everyone is comfortable using.
Since most people are alread familiar with skype and our group has alread conducted two meetings with it, skype might be the best tool for the job.

Discord, which is the most recent VoIP service released, is known for its very nice user interface.
This service also does not require a download.
Users can log on and join a Discord server using their browser.
Discord hosts its own servers which are very reliable.
Joining a call is very simple.
Whoever is hosting the server simply sends each group member a link.
Other group members simply click the link and join the voice server using either their web browser or downloaded application.
It also has a very good chat system.
Call quality is not limited to a group members poor internet.
Discord is also very light weight and puts much less strain on the cpu than Skype and Team Speak.
However, Discord does not have many of the Skype features including video calling and screen sharing.

Team Speak is best known for its sound quality.
Team Speak is the second oldest voice chat service, which has been in development since 2004. 
The newest version is Team Speak 3.
Team Speak has the greatest sound quality and reliability out of all three VoIP applications.
One of the big problems with Team Speak however is its user interface.
For beginner users it can be a lot more difficult to figure out.
Many reviewers say that it has the worst user interface design compared to Discord and Skype.
This is probably a product of its customizability.
There are many ways to improve a users experience with Team Speak including downloading user interface package downloads.
If there are only a couple of us in the group already familiar with how to use Team Speak then it probably isn't the best choice.
However, if everyone is alread accustomed to using Team Speak then our group might be able to benefit from Team Speak's greater flexibility.

For deciding what kind of camera we should use, there are a lot of factors to consider.
The camera will need to be able to record in HD with at least 30 frames per second.
The program will need to be able to make out shapes for its visual computing.
Leopard Imaging had partnered with NVIDIA to build cameras spceifically for the Jetson TX1.
This camera meets the miniumum requirements and was built specifically for machine vision.
There are many other HD cameras and Camcorders that are much less expensive but meet all the requirements.
However, the project might benefit from a camera built for visual computing.

There is also another camera offered by Leopard Imaging that shoots at 30 frames per second and has 4k resolution.
This camera is the same price as the one HD video camera.
Both are \$400.
A better resolution will allow our program to better understand what it is seeing and be able to compute accordingly.

There is also a camera that our client is supplying us.
This is likely the camera best used since it is provided freely and meets the needs of our project.
The camera is also recommended by our client for use with the Jetson TX1.

The third task involves figuring out how to visualize the data gathered from the program.
There are many ways in which this could be done.
We could have live data visualization, that shows the time, number of lives, number of near misses, and other such useful information to help gage how well the program is performing during the current playthrough.
We could have live data visualization that is also graphical and includes graphs and figures.
We could also have the data only appear at the end after the program has completed so that only the end result is displayed.
Live data visualization can offer a few things for data analysis.
In the beginning this might be very useful because during the start of the project the program may only survive a few seconds of the game.
Later however, when the program is beating more complicated levels, data gathered during the playthough could indicate areas where the program struggles.

Live data that can be displayed visually could enhance the benefits of seeing data gathered thoughout the playthrough.
Graphs that recorded which level the program lost a life at and what was the thing that hit it could easily be displayed visually to enhance comprehension.
There could be a lot of benefit to seeing a bar graph go up and down throughout the playthrough as the program loses or gains a life.
We could comparatively see how long it takes the program to complete each level.
This could be seen in real time and compared to how the program is actaully performing in the game.
One problem with live visualization is that it could also flood the screen with too much information, especially when the playthroughs get really long.

One benefit to having a smaller amount of data appear at the end giving a summary of the playthrough is the simplicity.
An end of game summary could provide more of the information we need and leave out a lot of unnecessary items.
A lot of information would be floating by on the screen as the program played the game.
A concrete summary might be a lot more efficient if it could compile all the data in a meaningful way.
A lot of the live information can also be gathered by just watching the playthrough.
We'll be able to see when the program lost a life or suddenly could not compute how to avoid objects.
We'll also be able to see what objects the program might have trouble seeing, which would be a hard thing to discover with just the data.





\end{document}
