%Copyright 2014 Jean-Philippe Eisenbarth
%This program is free software: you can
%redistribute it and/or modify it under the terms of the GNU General Public
%License as published by the Free Software Foundation, either version 3 of the
%License, or (at your option) any later version.
%This program is distributed in the hope that it will be useful,but WITHOUT ANY
%WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
%PARTICULAR PURPOSE. See the GNU General Public License for more details.
%You should have received a copy of the GNU General Public License along with
%this program.  If not, see <http://www.gnu.org/licenses/>.

%Based on the code of Yiannis Lazarides
%http://tex.stackexchange.com/questions/42602/software-requirements-specification-with-latex
%http://tex.stackexchange.com/users/963/yiannis-lazarides
%Also based on the template of Karl E. Wiegers
%http://www.se.rit.edu/~emad/teaching/slides/srs_template_sep14.pdf
%http://karlwiegers.com
% \documentclass[letterpaper,10pt]{article}
\documentclass{scrreprt}
\usepackage{listings}
\usepackage{underscore}
\usepackage[bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{alltt}
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{enumitem}

\usepackage{geometry}

\usepackage{titling}
\usepackage{rotating}
\usepackage{pgfgantt}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{anyfontsize}

\ganttset{group/.append style={orange},
milestone/.append style={red},
progress label node anchor/.append style={text=red}}

\geometry{textheight=8.5in, textwidth=6in}
\hypersetup{
    bookmarks=false,    % show bookmarks bar?
    pdftitle={Software Requirement Specification},    % title
    pdfauthor={Jean-Philippe Eisenbarth},                     % author
    pdfsubject={TeX and LaTeX},                        % subject of the document
    pdfkeywords={TeX, LaTeX, graphics, images}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,       % color of internal links
    citecolor=black,       % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=purple,        % color of external links
    linktoc=page            % only page is linked
}%
\def\myversion{1.01 }
\date{}
%\title{%

%}
\usepackage{hyperref}
\begin{document}

\begin{flushright}
    \rule{16cm}{5pt}\vskip1cm
    \begin{bfseries}
        \Huge{Technology Review and Implementation Plan}\\
        \vspace{1.9cm}
        for\\
        \vspace{1.9cm}
        Deep Learning on Embedded Platform\\
        \vspace{1.9cm}
        \LARGE{Version \myversion}\\
        \vspace{1.9cm}
        Prepared by Christopher Johnson, Luay Alshawi, Gabe Morey\\
        \vspace{1.9cm}
        CS 461 Fall Term\\
        \vspace{1.9cm}
        \today\\
    \end{bfseries}
\end{flushright}



The role of making sure everything runs smoothly on the platform required of us to implement out solution on can be devided into three categories.
These categories are finding the right communication methods with our client for group meetings, deciding what camera technology we need, and figuring out the best way to visialize the data.
For each of these three tasks I have found three approaches that I have research and given thorough consideration.
This is to ensure that we are making the best possible decisions when working with the Jetson TX1.

There are many very popular and suitable tools available to conduct online meetings.
These include Skype, Discord, and Team Speak.
Skype was founded in 2003 by Niklas Zennstr√∂m.
Skype has a lot of features that Discord and Team Speak don't have.
One of these features includes screen sharing.
This feature could be very beneficial during group meetings when a group member has to explain something visually.
Our group has used Skype twice in the past and the sound quality was good enough for everyone to understand each other.
Discord and Team Speak also do not allow video calls, they only provide groups to voice and text chat.
One down side with Skype however is the presence of bugs.
Among reviewers, skype is the least reliable.

Discord, which is the most recent VoIP service released, is known for its very nice user interface.
This service also does not require a download.
Users can log on and join a Discord server using their browser.
Discord hosts its own servers which are very reliable.
Call quality is not limited to a group members poor internet.
Discord is also very light weight and puts much less strain on the cpu than Skype and Team Speak.
However, Discord does not have many of the Skype features including video calling and screen sharing.

Team Speak is known for its sound quality.
Team Speak is the second oldest voice chat service, which has been in development since 2004. 
The newest version is Team Speak 3.
Team Speak has the greatest sound quality and reliability out of all three VoIP applications.
One of the big problems with Team Speak however is its user interface.
For beginner users it can be a lot more difficult to figure out.
Many reviewers say that it has the worst user interface design compared to Discord and Skype.
This is probably a product of its customizability.
There are many ways to improve a users experience with Team Speak including downloading user interface package downloads.

For deciding what kind of camera we should use, there are a lot of factors to consider.
The camera will need to be able to record in HD with at least 30 frames per second.
The program will need to be able to make out shapes for its visual computing.
Leopard Imaging had partnered with NVIDIA to build cameras spceifically for the Jetson TX1.
This camera meets the miniumum requirements and was built specifically for machine vision.

There is also another camera offered by Leopard Imaging that shoots at 30 frames per second and has 4k resolution.
This camera is the same price as the one HD video camera.
Both are \$400.
A better resolution will allow our program to better understand what it is seeing and be able to compute accordingly.

There is also a camera that our client is supplying us.
This is likely the camera best used since it is provided freely and meets the needs of our project.

The third task involves figuring out how to visualize the data gathered from the program.
There are many ways in which this could be done.
We could have live data visualization, that shows the time, number of lives, number of near misses, and other such useful information to help gage how well the program is performing during the current playthrough.
We could have live data visualization that is also graphical and includes graphs and figures.
We could also have the data only appear at the end after the program has completed so that only the end result is displayed.
Live data visualization can offer a few things for data analysis.
In the beginning this might be very useful because during the start of the project the program may only survive a few seconds of the game.
Later however, when the program is beating more complicated levels, data gathered during the playthough could indicate areas where the program struggles.

Live data that can be displayed visually could enhance the benefits of seeing data gathered thoughout the playthrough.
Graphs that recorded which level the program lost a life at and what was the thing that hit it could easily be displayed visually to enhance comprehension.
One problem with live visualization is that it could also flood the screen with too much information, especially when the playthroughs get really long.

One benefit to having a smaller amount of data appear at the end giving a summary of the playthrough is the simplicity.
An end of game summary could previde more of the information we need and leave out a lot of unnecessary items.
A lot of the live information can also be gathered by just watching the playthrough.
We'll be able to see when the program lost a life or suddenly could not compute how to avoid objects.





\end{document}